#' Visualize Near-Infrared Spectroscopy Time Series for Individual Sensors
#' @author Christian L. Goueguel
#' @description
#' This function performs detailed time series analysis and visualization of 
#' Near-Infrared Spectroscopy (NIRS) data for a specified sensor, focusing on 
#' samples with repeated measurements over time. The function identifies tubes 
#' that have been measured multiple times, extracts their spectral evolution 
#' patterns, and generates comprehensive visualizations showing how spectral 
#' characteristics change temporally.
#' @param nir_data A list object generated by the process_nir_data() function 
#'   containing processed NIR spectroscopy data. The list must include a 
#'   'corrected_spectra' element containing a data frame with columns for 
#'   'sensor', 'tube_number', 'datetime', and 'spec_array'. The spec_array 
#'   column should contain numeric vectors representing spectral intensities 
#'   across wavelengths.
#' @param target_sensor Character string specifying the sensor to analyze 
#'   (default: "sensor_1"). This must match exactly one of the sensor 
#'   identifiers present in the corrected_spectra data frame. The function 
#'   filters all data to focus exclusively on measurements from this sensor, 
#'   enabling detailed temporal analysis of sensor-specific patterns.
#' @param min_measurements Integer value specifying the minimum number of 
#'   measurements required for a tube to be included in time series analysis 
#'   (default: 2). Tubes with fewer measurements than this threshold are 
#'   excluded from temporal visualization, though they remain in frequency 
#'   statistics.
#' @return A list containing two elements that provide comprehensive temporal 
#'   analysis results. The first element, 'repeated_samples', contains a data 
#'   frame listing all tubes meeting the minimum measurement criterion, sorted 
#'   by measurement frequency, including temporal span and boundary timestamps 
#'   for each tube. The second element, 'plot', contains either a time series 
#'   visualization showing spectral evolution for frequently measured tubes when 
#'   sufficient repeated measurements exist, or a histogram displaying measurement 
#'   frequency distribution when repeated measurements are insufficient for 
#'   time series analysis.
#' @export
visualize_nirs_time_series <- function(
    nir_data,
    target_sensor = "sensor_1",
    min_measurements = 2,
    seed = 123
) {
  
  set.seed(seed)
  
  if (missing(nir_data)) {
    stop("Argument 'nir_data' is required. ",
         "Please provide output from process_nir_data() function.")
  }
  if (!is.list(nir_data)) {
    stop("Argument 'nir_data' must be a list object, ",
         "typically output from process_nir_data() function.")
  }
  if (!"corrected_spectra" %in% names(nir_data)) {
    stop("Input 'nir_data' must contain a 'corrected_spectra' element. ",
         "Ensure data has been processed through process_nir_data() function.")
  }
  if (!is.data.frame(nir_data$corrected_spectra)) {
    stop("The 'corrected_spectra' element must be a data frame.")
  }
  if (nrow(nir_data$corrected_spectra) == 0) {
    stop("The 'corrected_spectra' data frame is empty. ",
         "No data available for time series visualization.")
  }
  if (!is.character(target_sensor) || length(target_sensor) != 1) {
    stop("Argument 'target_sensor' must be a single character string.")
  }
  
  available_sensors <- unique(nir_data$corrected_spectra$sensor)
  if (!target_sensor %in% available_sensors) {
    stop(sprintf("Target sensor '%s' not found in data. Available sensors: %s",
                 target_sensor, paste(available_sensors, collapse = ", ")))
  }
  if (!is.numeric(min_measurements) || length(min_measurements) != 1) {
    stop("Argument 'min_measurements' must be a single numeric value.")
  }
  if (min_measurements < 1) {
    stop("Argument 'min_measurements' must be at least 1.")
  }
  if (min_measurements != round(min_measurements)) {
    warning("Argument 'min_measurements' should be an integer. ",
            sprintf("Rounding %.2f to %d.", min_measurements, round(min_measurements)))
    min_measurements <- round(min_measurements)
  }
  
  required_cols <- c("sensor", "tube_number", "datetime", "spec_array")
  missing_cols <- setdiff(required_cols, names(nir_data$corrected_spectra))
  if (length(missing_cols) > 0) {
    stop(sprintf("Required column(s) missing from corrected_spectra: %s",
                 paste(missing_cols, collapse = ", ")))
  }
  
  required_packages <- c("dplyr", "ggplot2", "viridis")
  for (pkg in required_packages) {
    if (!requireNamespace(pkg, quietly = TRUE)) {
      stop(sprintf("Package '%s' is required but not installed. ", pkg),
           sprintf("Please install it with: install.packages('%s')", pkg))
    }
  }
  
  sensor_data <- nir_data$corrected_spectra %>%
    filter(sensor == target_sensor) %>%
    mutate(datetime = as.POSIXct(datetime))
  
  if (any(is.na(sensor_data$datetime))) {
    n_failed <- sum(is.na(sensor_data$datetime))
    warning(sprintf("Failed to convert %d datetime values. ", n_failed),
            "These records will be excluded from analysis.")
    sensor_data <- sensor_data %>% filter(!is.na(datetime))
  }
  
  cat("\n=== Time Series Analysis for", target_sensor, "===\n")
  cat("Total measurements:", nrow(sensor_data), "\n")
  
  if (nrow(sensor_data) == 0) {
    stop(sprintf("No valid data found for sensor '%s' after datetime conversion.", 
                 target_sensor))
  }
  
  repeated_samples <- sensor_data %>%
    group_by(tube_number) %>%
    summarise(
      n_measurements = n(),
      time_span = difftime(max(datetime), min(datetime), units = "hours"),
      first_measurement = min(datetime),
      last_measurement = max(datetime),
      .groups = "drop"
    ) %>%
    filter(n_measurements >= min_measurements) %>%
    arrange(desc(n_measurements))
  
  cat("Samples with", min_measurements, "or more measurements:", 
      nrow(repeated_samples), "\n")
  
  if (nrow(repeated_samples) == 0) {
    cat("No samples found with repeated measurements for time series analysis.\n")
    cat("Showing measurement frequency instead...\n")
    p1 <- sensor_data %>%
      ggplot(aes(x = datetime)) +
      geom_histogram(
        bins = 30, 
        fill = "steelblue", 
        alpha = 0.7,
        color = "white",
        size = 0.2
      ) +
      labs(
        title = paste("Measurement Frequency Over Time -", target_sensor),
        subtitle = sprintf("Total measurements: %d | All tubes measured < %d times",
                           nrow(sensor_data), min_measurements),
        x = "Date/Time",
        y = "Number of Measurements",
        caption = "Histogram shows temporal distribution of all measurements"
      ) +
      theme_minimal() +
      theme(
        plot.title = element_text(size = 14, face = "bold"),
        plot.subtitle = element_text(size = 10, color = "gray40"),
        axis.title = element_text(size = 11),
        panel.grid.minor = element_blank()
      )
    return(list(
      repeated_samples = repeated_samples, 
      plot = p1
    ))
  }
  
  samples_to_plot <- repeated_samples %>%
    slice_sample(n = 6) %>%
    pull(tube_number)
  
  cat("\nPlotting time series for tubes:", paste(samples_to_plot, collapse = ", "), "\n")
  
  selected_stats <- repeated_samples %>%
    filter(tube_number %in% samples_to_plot) %>%
    mutate(time_span_formatted = sprintf("%.1f hours", as.numeric(time_span)))
  
  cat("\nSelected tube statistics:\n")
  for (i in seq_len(nrow(selected_stats))) {
    cat(sprintf("  Tube %s: %d measurements over %s\n",
                selected_stats$tube_number[i],
                selected_stats$n_measurements[i],
                selected_stats$time_span_formatted[i]))
  }
  
  time_series_data <- sensor_data %>%
    filter(tube_number %in% samples_to_plot) %>%
    arrange(tube_number, datetime)
  
  if (!all(sapply(time_series_data$spec_array, is.numeric))) {
    warning("Some spec_array entries are not numeric vectors. ", "These will be excluded from visualization.")
  }
  
  extract_spectral_data <- function(data) {
    spectral_list <- list()
    for (i in 1:nrow(data)) {
      spec_array <- data$spec_array[[i]]
      if (!is.numeric(spec_array) || length(spec_array) == 0) {
        warning(sprintf("Invalid spec_array at row %d, skipping", i))
        next
      }
      spec_df <- data.frame(
        wavelength_index = 1:length(spec_array),
        intensity = as.numeric(spec_array),
        tube_number = data$tube_number[i],
        datetime = data$datetime[i],
        measurement_id = paste(data$tube_number[i], format(data$datetime[i], "%Y-%m-%d %H:%M:%S"))
      )
      spectral_list[[length(spectral_list) + 1]] <- spec_df
    }
    if (length(spectral_list) == 0) {
      stop("No valid spectral data could be extracted for visualization")
    }
    
    do.call(rbind, spectral_list)
  }
  
  spectral_data <- tryCatch({
    extract_spectral_data(time_series_data)
  }, error = function(e) {
    stop(sprintf("Failed to extract spectral data: %s", e$message))
  })
  
  n_spectra <- length(unique(spectral_data$measurement_id))
  n_wavelengths <- max(spectral_data$wavelength_index)
  cat(sprintf("\nPrepared %d spectra with %d wavelength points each\n", n_spectra, n_wavelengths))
  
  p2 <- spectral_data %>%
    ggplot(aes(
      x = wavelength_index,
      y = intensity,
      color = datetime,
      group = measurement_id
    )) +
    geom_line(
      alpha = 0.7, 
      size = 0.5
    ) +
    facet_wrap(
      ~ tube_number,
      scales = "free_y",
      labeller = labeller(
        tube_number = function(x) paste("Tube", x)
      )
    ) +
    scale_color_viridis_c(
      name = "Time", 
      trans = "time",
      option = "viridis",
      guide = guide_colorbar(
        title.position = "top",
        title.hjust = 0.5,
        barwidth = unit(10, "cm"),
        barheight = unit(0.5, "cm")
      )
    ) +
    labs(
      title = paste("NIRS Spectra Time Series -", target_sensor),
      subtitle = sprintf("Showing %d tubes with %d+ measurements each",
                         length(samples_to_plot), min_measurements),
      x = "Wavelength Index",
      y = "Corrected Intensity",
      caption = "Colors represent measurement time (darker = earlier, lighter = later)"
    ) +
    theme_minimal() +
    theme(
      strip.text = element_text(size = 10, face = "bold"),
      legend.position = "bottom",
      legend.title = element_text(size = 10),
      plot.title = element_text(size = 14, face = "bold"),
      plot.subtitle = element_text(size = 10, color = "gray40"),
      panel.spacing = unit(1, "lines"),
      axis.title = element_text(size = 11)
    )
  
  return(p2)
}