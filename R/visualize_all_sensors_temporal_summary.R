#' Visualize Temporal Summary and Timeline for Multi-Sensor NIR Data
#' @author Christian L. Goueguel
#' @description
#' This function generates temporal visualizations and summary 
#' statistics for processed NIR spectroscopy data collected from multiple sensors. 
#' It provides both tabular summaries and graphical representations of measurement 
#' patterns across time, enabling quality assessment, experimental timeline 
#' validation, and identification of temporal anomalies or gaps in data collection. 
#' @param nir_data A list object generated by the `process_nir_data()` function 
#'   containing processed NIR spectroscopy data. Must include a 'corrected_spectra' 
#'   element containing a data frame with columns for 'datetime', 'sensor', and 
#'   'tube_number'. The datetime column should be convertible to POSIXct format 
#'   for proper temporal analysis. This parameter typically represents the complete 
#'   output from the NIR data processing pipeline.
#' @return A named list containing two elements that provide complementary views 
#'   of the temporal data structure:
#'   \describe{
#'     \item{summary}{A tibble containing temporal statistics for each sensor, 
#'                    including total measurement count, unique tube count, time 
#'                    range boundaries, span duration in hours, and average 
#'                    measurements per tube.}
#'     \item{timeline_plot}{A ggplot2 object displaying the temporal distribution of measurements across all sensors.}
#'   }
#' @details
#' The function performs multi-faceted temporal analysis to support data quality 
#' assessment and experimental validation through several coordinated operations.
#' 
#' Temporal Data Processing: The function begins by converting datetime strings 
#' to POSIXct objects, ensuring proper temporal ordering and enabling accurate 
#' time-based calculations. This conversion handles various datetime formats 
#' automatically through R's POSIXct parsing capabilities, though consistent 
#' formatting in the input data improves reliability.
#' 
#' Statistical Summarization: For each sensor, the function calculates comprehensive 
#' temporal metrics including the total number of measurements, count of unique 
#' tubes analyzed, temporal boundaries defining the earliest and latest measurements, 
#' and the total time span of data collection. These metrics enable rapid assessment 
#' of whether each sensor operated according to experimental protocols and whether 
#' data collection was complete.
#' 
#' Data Density Analysis: The function computes average measurements per tube, 
#' providing insight into measurement replication levels and helping identify 
#' whether certain tubes were measured more frequently than others. This metric 
#' proves particularly valuable for identifying systematic biases in data collection 
#' or technical issues affecting specific tubes.
#' 
#' Visual Timeline Generation: The timeline plot represents each measurement as 
#' a point positioned according to its timestamp and sensor identity.
#'
#' @export visualize_all_sensors_temporal_summary
visualize_all_sensors_temporal_summary <- function(nir_data) {
  if (missing(nir_data)) {
    stop("Argument 'nir_data' is required. ",
         "Please provide output from process_nir_data() function.")
  }
  if (!is.list(nir_data)) {
    stop("Argument 'nir_data' must be a list object, ",
         "typically output from process_nir_data() function.")
  }
  if (!"corrected_spectra" %in% names(nir_data)) {
    stop("Input 'nir_data' must contain a 'corrected_spectra' element. ",
         "Ensure data has been processed through process_nir_data() function.")
  }
  if (!is.data.frame(nir_data$corrected_spectra)) {
    stop("The 'corrected_spectra' element must be a data frame.")
  }
  if (nrow(nir_data$corrected_spectra) == 0) {
    stop("The 'corrected_spectra' data frame is empty. ",
         "No data available for temporal visualization.")
  }
  required_cols <- c("datetime", "sensor", "tube_number")
  missing_cols <- setdiff(required_cols, names(nir_data$corrected_spectra))
  if (length(missing_cols) > 0) {
    stop(sprintf("Required column(s) missing from corrected_spectra: %s",
                 paste(missing_cols, collapse = ", ")))
  }
  if (!requireNamespace("dplyr", quietly = TRUE)) {
    stop("Package 'dplyr' is required but not installed. ",
         "Please install it with: install.packages('dplyr')")
  }
  if (!requireNamespace("ggplot2", quietly = TRUE)) {
    stop("Package 'ggplot2' is required but not installed. ",
         "Please install it with: install.packages('ggplot2')")
  }
  if (!requireNamespace("ggsci", quietly = TRUE)) {
    stop("Package 'ggsci' is required but not installed. ",
         "Please install it with: install.packages('ggsci')")
  }

  temporal_summary <- tryCatch({
    nir_data$corrected_spectra %>%
      mutate(datetime = as.POSIXct(datetime)) %>%
      group_by(sensor) %>%
      summarise(
        n_measurements = n(),
        n_unique_tubes = n_distinct(tube_number),
        min_time = min(datetime, na.rm = TRUE),
        max_time = max(datetime, na.rm = TRUE),
        time_span_hours = as.numeric(difftime(
          max(datetime, na.rm = TRUE), 
          min(datetime, na.rm = TRUE), 
          units = "hours"
        )),
        .groups = "drop"
      ) %>%
      mutate(
        avg_measurements_per_tube = round(n_measurements / n_unique_tubes, 2)
      )
  }, error = function(e) {
    stop(sprintf("Failed to generate temporal summary: %s", e$message))
  })
  
  if (nrow(temporal_summary) == 0) {
    warning("Temporal summary is empty. Check input data structure.")
  }
  
  datetime_check <- nir_data$corrected_spectra %>%
    mutate(datetime_converted = as.POSIXct(datetime))
  
  if (any(is.na(datetime_check$datetime_converted))) {
    n_failed <- sum(is.na(datetime_check$datetime_converted))
    total_n <- nrow(datetime_check)
    warning(sprintf("Failed to convert %d out of %d datetime values. ", n_failed, total_n),
            "These records will be excluded from analysis.")
  }
  
  cat("\nTemporal Summary by Sensor:\n")
  cat("=" , strrep("=", 70), "\n", sep = "")
  print(temporal_summary, n = Inf)
  cat("\n")
  
  p_timeline <- tryCatch({
    nir_data$corrected_spectra %>%
      mutate(datetime = as.POSIXct(datetime)) %>%
      filter(!is.na(datetime)) %>%
      ggplot(aes(x = datetime, y = sensor, color = sensor)) +
      geom_point(
        alpha = 0.6,  
        size = 0.5,   
        position = position_jitter(height = 0.2, width = 0)  
      ) +
      ggsci::scale_color_ucscgb() +  
      labs(
        title = "Measurement Timeline Across All Sensors",
        subtitle = sprintf("Total measurements: %d | Date range: %s to %s",
                           nrow(nir_data$corrected_spectra),
                           format(min(temporal_summary$min_time), "%Y-%m-%d"),
                           format(max(temporal_summary$max_time), "%Y-%m-%d")),
        x = "Date/Time",
        y = "",
        caption = "Each point represents one spectral measurement"
      ) +
      theme_minimal() +
      theme(
        legend.position = "none",  
        panel.grid.minor = element_blank(), 
        plot.title = element_text(size = 14, face = "bold"),
        plot.subtitle = element_text(size = 10, color = "gray40")
      )
  }, error = function(e) {
    warning(sprintf("Failed to generate timeline plot: %s", e$message))
    NULL
  })
  
  if (!is.null(p_timeline)) {
    print(p_timeline)
  } else {
    warning("Timeline plot could not be generated. ",
            "Check datetime formatting and data structure.")
  }
  
  low_measurement_sensors <- temporal_summary %>%
    filter(n_measurements < 10)
  
  if (nrow(low_measurement_sensors) > 0) {
    warning(sprintf("The following sensor(s) have fewer than 10 measurements: %s",
                    paste(low_measurement_sensors$sensor, collapse = ", ")))
  }
  
  sensors_with_gaps <- temporal_summary %>%
    filter(time_span_hours > 24 & n_measurements < 100)
  
  if (nrow(sensors_with_gaps) > 0) {
    cat("\nNote: The following sensor(s) show sparse temporal coverage:\n")
    for (i in seq_len(nrow(sensors_with_gaps))) {
      cat(sprintf("  - %s: %.1f hours span with only %d measurements\n",
                  sensors_with_gaps$sensor[i],
                  sensors_with_gaps$time_span_hours[i],
                  sensors_with_gaps$n_measurements[i]))
    }
  }
  
  return(
    list(
      summary = temporal_summary,
      timeline_plot = p_timeline
    )
  )
}