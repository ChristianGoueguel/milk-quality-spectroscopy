---
output: 
  github_document:
    toc: true
    toc_depth: 4
    fig_width: 8
    fig_height: 6
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%",
  fig.retina = 2,
  fig.align = "center",
  dpi = 300,
  warning = FALSE,
  message = FALSE,
  echo = TRUE,
  cache = FALSE,
  dev = "png"
)
```

# Milk Quality Spectroscopy {-}

<!-- badges: start -->
<!-- badges: end -->

```{r}
if (requireNamespace("ggplot2", quietly = TRUE)) {
  ggplot2::theme_set(ggplot2::theme_minimal(base_size = 12))
}
```

```{r}
set.seed(123)
```

```{r}
suppressPackageStartupMessages({
  library(tidyverse)
  library(viridis)
  library(arrow) 
})
```

# Dataset
The data is structured by sensor/stall with each sensor directory containing:

  - **Lab results** (CSV format with tube_no as primary key)
  - **Sensor configuration** (wavelengths, calibration coefficients)
  - **Spectral measurements** (Parquet files, one per milk sample)
  - **Dark spectra** (reference measurements)

## Key data components

**Lab Results**: Milk analysis including fat percentage, protein, somatic cell count and, lactose linked to specific cows and milking sessions.

**Spectral Data**: Raw 16-bit spectral arrays captured during milking, with metadata like temperature, LED current, and integration time. Each spectrum is classified as "dark," "sample," or "empty."

**Sensor Info**: Each sensor has unique wavelength calibrations and measurement parameters that aren't standardized across sensors.

## Important limitations

  - Temperature and LED measurements are raw ADC values, not standardized between sensors
  - Each sensor measures different wavelengths
  - Some timing discrepancies remain due to clock source differences

## Data evolution
The dataset has evolved from initial CSV format to Parquet compression, with spectral data consolidated into array columns rather than individual wavelength columns for more efficient storage and processing.

## Data processing

```{r}
dataset_path <- "Dataset/"
read_sensor_csvs <- function(sensor_folder) {
  sensor_path <- file.path(dataset_path, sensor_folder)
  lab_results <- read_csv(file.path(sensor_path, "lab_results.csv"), show_col_types = FALSE)
  lab_results$sensor <- sensor_folder
  sensor_data <- read_csv(file.path(sensor_path, "sensor.csv"), show_col_types = FALSE)
  sensor_data$sensor <- sensor_folder
  return(list(lab_results = lab_results, sensor_data = sensor_data))
}
```

```{r}
read_sensor_parquets <- function(sensor_folder) {
  sensor_path <- file.path(dataset_path, sensor_folder)
  dark_spectra_path <- file.path(sensor_path, "dark_spectra", "dark_spectra.parquet")
  dark_spectra <- read_parquet(dark_spectra_path)
  spectra_path <- file.path(sensor_path, "spectra")
  tube_files <- list.files(spectra_path, pattern = "tube_no_\\d+\\.parquet$", full.names = TRUE)
  tube_spectra_list <- map(tube_files, read_parquet)
  names(tube_spectra_list) <- basename(tube_files)
  dark_spectra$sensor <- sensor_folder
  
  tube_spectra_list <- map(tube_spectra_list, ~ {
    .x$sensor <- sensor_folder
    return(.x)
  })
  
  return(list(dark_spectra = dark_spectra, tube_spectra = tube_spectra_list))
}
```

```{r}
subtract_dark_spectrum <- function(tube_spectrum, dark_spectrum, verbose = FALSE) {
  if (nrow(tube_spectrum) != nrow(dark_spectrum)) {
    if (verbose) {
      cat(
        "Row count mismatch - Tube:",
        nrow(tube_spectrum),
        "Dark:",
        nrow(dark_spectrum),
        "- Trimming to",
        min(nrow(tube_spectrum), nrow(dark_spectrum)),
        "rows\n"
      )
    }
    min_rows <- min(nrow(tube_spectrum), nrow(dark_spectrum))
    tube_spectrum <- tube_spectrum[1:min_rows, ]
    dark_spectrum <- dark_spectrum[1:min_rows, ]
  }
  spectral_cols <- names(tube_spectrum)[sapply(tube_spectrum, is.numeric)]
  spectral_cols <- spectral_cols[spectral_cols != "sensor"]
  corrected_spectrum <- tube_spectrum
  
  for (col in spectral_cols) {
    if (col %in% names(dark_spectrum)) {
      if (length(tube_spectrum[[col]]) == length(dark_spectrum[[col]])) {
        corrected_spectrum[[col]] <- tube_spectrum[[col]] - dark_spectrum[[col]]
      } else {
        if (verbose) {
          cat("Column", col, "length mismatch, skipping\n")
        }
      }
    }
  }
  return(corrected_spectrum)
}
```

```{r}
process_nir_data <- function(verbose = FALSE) {
  sensor_folders <- paste0("sensor_", 1:12)
  
  cat("Processing CSV files...\n")
  csv_data <- map(sensor_folders, read_sensor_csvs)
  names(csv_data) <- sensor_folders
  all_lab_results <- map_dfr(csv_data, ~ .x$lab_results)
  all_sensor_data <- map_dfr(csv_data, ~ .x$sensor_data)
  
  cat("Processing parquet files...\n")
  parquet_data <- map(sensor_folders, read_sensor_parquets)
  names(parquet_data) <- sensor_folders
  all_dark_spectra <- map_dfr(parquet_data, ~ .x$dark_spectra)
  corrected_spectra_list <- list()
  
  for (sensor in sensor_folders) {
    if (verbose) {
      cat(paste("Processing", sensor, "...\n"))
    } else {
      cat(".")
    }
    
    dark_spectrum <- parquet_data[[sensor]]$dark_spectra
    tube_spectra <- parquet_data[[sensor]]$tube_spectra
    corrected_tubes <- map(
      tube_spectra,
      ~ subtract_dark_spectrum(.x, dark_spectrum, verbose = verbose)
      )
    
    for (i in seq_along(corrected_tubes)) {
      tube_file <- names(corrected_tubes)[i]
      tube_number <- gsub("tube_no_(\\d+)\\.parquet", "\\1", tube_file)
      corrected_tubes[[i]]$tube_number <- tube_number
    }
    corrected_spectra_list[[sensor]] <- corrected_tubes
  }
  
  cat("\n")
  all_corrected_spectra <- map_dfr(corrected_spectra_list, ~ map_dfr(.x, identity))
  cat("Data processing complete!\n")
  
  return(
    list(
      lab_results = all_lab_results,
      sensor_data = all_sensor_data,
      dark_spectra = all_dark_spectra,
      corrected_spectra = all_corrected_spectra
    )
  )
}
```

```{r message=FALSE, warning=FALSE}
nir_data <- process_nir_data(verbose = FALSE)
```

```{r}
cat("\n=== Data Summary ===\n")
cat("Lab results shape:", nrow(nir_data$lab_results), "x", ncol(nir_data$lab_results), "\n")
cat("Sensor data shape:", nrow(nir_data$sensor_data), "x", ncol(nir_data$sensor_data), "\n")
cat("Dark spectra shape:", nrow(nir_data$dark_spectra), "x", ncol(nir_data$dark_spectra), "\n")
cat("Corrected spectra shape:", nrow(nir_data$corrected_spectra), "x", ncol(nir_data$corrected_spectra), "\n")
cat("\nUnique sensors in corrected spectra:", length(unique(nir_data$corrected_spectra$sensor)), "\n")
cat("Unique tube numbers:", length(unique(nir_data$corrected_spectra$tube_number)), "\n")
```

```{r}
nir_data$lab_results
```

```{r}
nir_data$sensor_data
```

### Time Series Visualization

```{r}
visualize_all_sensors_temporal_summary <- function(nir_data) {
  temporal_summary <- nir_data$corrected_spectra %>%
    mutate(datetime = as.POSIXct(datetime)) %>%
    group_by(sensor) %>%
    summarise(
      n_measurements = n(),
      n_unique_tubes = n_distinct(tube_number),
      min_time = min(datetime),
      max_time = max(datetime),
      time_span_hours = as.numeric(difftime(max(datetime), min(datetime), units = "hours")),
      .groups = "drop"
    ) %>%
    mutate(avg_measurements_per_tube = round(n_measurements / n_unique_tubes, 2))
  print(temporal_summary)
  
  p_timeline <- nir_data$corrected_spectra %>%
    mutate(datetime = as.POSIXct(datetime)) %>%
    ggplot(aes(x = datetime, y = sensor, color = sensor)) +
    geom_point(alpha = 0.6, size = .5) +
    ggsci::scale_color_ucscgb() +
    labs(
      title = "Measurement Timeline Across All Sensors",
      x = "Date/Time",
      y = " ",
      caption = "Each point represents one spectral measurement"
    ) +
    theme_minimal() +
    theme(legend.position = "none")
  
  print(p_timeline)
  return(list(summary = temporal_summary, timeline_plot = p_timeline))
}
```

```{r}
all_sensors_summary <- visualize_all_sensors_temporal_summary(nir_data)
```

```{r}
visualize_nirs_time_series <- function(
    nir_data,
    target_sensor = "sensor_1",
    min_measurements = 2
    ) {
  sensor_data <- nir_data$corrected_spectra %>%
    filter(sensor == target_sensor) %>%
    mutate(datetime = as.POSIXct(datetime))
  
  cat("=== Time Series Analysis for", target_sensor, "===\n")
  cat("Total measurements:", nrow(sensor_data), "\n")
  
  repeated_samples <- sensor_data %>%
    group_by(tube_number) %>%
    summarise(
      n_measurements = n(),
      time_span = difftime(max(datetime), min(datetime), units = "hours"),
      first_measurement = min(datetime),
      last_measurement = max(datetime),
      .groups = "drop"
    ) %>%
    filter(n_measurements >= min_measurements) %>%
    arrange(desc(n_measurements))
  
  cat(
    "Samples with",
    min_measurements,
    "or more measurements:",
    nrow(repeated_samples),
    "\n"
  )
  
  if (nrow(repeated_samples) == 0) {
    cat("No samples found with repeated measurements for time series analysis.\n")
    cat("Showing measurement frequency instead...\n")
    
    p1 <- sensor_data %>%
      ggplot(aes(x = datetime)) +
      geom_histogram(bins = 30, fill = "steelblue", alpha = 0.7) +
      labs(
        title = paste("Measurement Frequency Over Time -", target_sensor),
        x = "Date/Time",
        y = "Number of Measurements"
      ) +
      theme_minimal()
    
    print(p1)
    return(list(repeated_samples = repeated_samples, plot = p1))
  }
  
  samples_to_plot <- repeated_samples %>%
    slice_head(n = 5) %>%
    pull(tube_number)
  
  cat(
    "\nPlotting time series for tubes:",
    paste(samples_to_plot, collapse = ", "),
    "\n"
    )
  
  time_series_data <- sensor_data %>%
    filter(tube_number %in% samples_to_plot) %>%
    arrange(tube_number, datetime)
  
  extract_spectral_data <- function(data) {
    spectral_list <- list()
    for (i in 1:nrow(data)) {
      spec_array <- data$spec_array[[i]]
      spec_df <- data.frame(
        wavelength_index = 1:length(spec_array),
        intensity = as.numeric(spec_array),
        tube_number = data$tube_number[i],
        datetime = data$datetime[i],
        measurement_id = paste(data$tube_number[i], data$datetime[i])
      )
      spectral_list[[i]] <- spec_df
    }
    do.call(rbind, spectral_list)
  }
  
  spectral_data <- extract_spectral_data(time_series_data)
  
  p2 <- spectral_data %>%
    ggplot(aes(
      x = wavelength_index,
      y = intensity,
      color = datetime,
      group = measurement_id
    )) +
    geom_line(alpha = 0.7, size = 0.5) +
    facet_wrap(
      ~ tube_number,
      scales = "free_y",
      labeller = labeller(
        tube_number = function(x)
          paste("Tube", x)
      )
    ) +
    scale_color_viridis_c(name = "Time", trans = "time") +
    labs(
      title = paste("NIRS Spectra Time Series -", target_sensor),
      subtitle = "Each line represents a spectrum at a different time point",
      x = "Wavelength Index",
      y = "Corrected Intensity",
      caption = "Colors represent measurement time (darker = earlier, lighter = later)"
    ) +
    theme_minimal() +
    theme(
      strip.text = element_text(size = 10, face = "bold"),
      legend.position = "bottom")
  print(p2)
}
```

```{r}
visualize_nirs_time_series(nir_data, "sensor_1", min_measurements = 2)
```

### Saturated spectra

```{r}
detect_and_handle_saturation <- function(nir_data,
                                         saturation_threshold = 60000,
                                         saturation_percentage = 0.05,
                                         method = "flag") {
  cat("=== Saturation Detection and Handling ===\n")
  is_saturated <- function(spec_array,
                           threshold = saturation_threshold,
                           percentage = saturation_percentage) {
    if (is.null(spec_array) || length(spec_array) == 0)
      return(FALSE)
    n_saturated <- sum(spec_array >= threshold, na.rm = TRUE)
    saturation_ratio <- n_saturated / length(spec_array)
    return(saturation_ratio >= percentage)
  }
  
  corrected_data <- nir_data$corrected_spectra %>%
    rowwise() %>%
    mutate(
      max_intensity = max(spec_array, na.rm = TRUE),
      mean_intensity = mean(spec_array, na.rm = TRUE),
      is_saturated = is_saturated(spec_array, saturation_threshold, saturation_percentage),
      n_saturated_points = sum(spec_array >= saturation_threshold, na.rm = TRUE),
      saturation_percentage = n_saturated_points / length(spec_array) * 100
    ) %>%
    ungroup()
  
  saturation_summary <- corrected_data %>%
    group_by(sensor) %>%
    summarise(
      total_spectra = n(),
      saturated_spectra = sum(is_saturated),
      saturation_rate = round(saturated_spectra / total_spectra * 100, 2),
      max_intensity_overall = max(max_intensity, na.rm = TRUE),
      mean_max_intensity = round(mean(max_intensity, na.rm = TRUE), 0),
      .groups = "drop"
    )
  
  cat("Saturation Summary by Sensor:\n")
  print(saturation_summary)
  total_saturated <- sum(corrected_data$is_saturated)
  total_spectra <- nrow(corrected_data)
  overall_rate <- round(total_saturated / total_spectra * 100, 2)
  
  cat(
    sprintf(
      "\nOverall: %d/%d spectra saturated (%.2f%%)\n",
      total_saturated,
      total_spectra,
      overall_rate
    )
  )
  
  if (method == "remove") {
    cat("\nRemoving saturated spectra...\n")
    clean_data <- corrected_data %>% filter(!is_saturated)
    cat(
      sprintf(
        "Removed %d saturated spectra. %d spectra remaining.\n",
        total_saturated,
        nrow(clean_data)
      )
    )
    
  } else if (method == "cap") {
    cat(sprintf(
      "\nCapping intensities at threshold: %d\n",
      saturation_threshold
    ))
    clean_data <- corrected_data %>%
      rowwise() %>%
      mutate(spec_array = list(pmin(spec_array, saturation_threshold))) %>%
      ungroup()
    
  } else if (method == "interpolate") {
    cat("\nInterpolating saturated regions...\n")
    clean_data <- corrected_data %>%
      rowwise() %>%
      mutate(spec_array = list(
        interpolate_saturated_points(spec_array, saturation_threshold)
      )) %>%
      ungroup()
    
  } else {
    cat("\nFlagging saturated spectra (no removal/modification)\n")
    clean_data <- corrected_data
  }
  
  return(
    list(
      data = clean_data,
      saturation_summary = saturation_summary,
      total_saturated = total_saturated,
      saturation_rate = overall_rate
    )
  )
}
```

```{r}
interpolate_saturated_points <- function(spec_array, threshold) {
  if (is.null(spec_array) ||
      length(spec_array) == 0)
    return(spec_array)
  
  saturated_idx <- which(spec_array >= threshold)
  if (length(saturated_idx) == 0)
    return(spec_array)
  spec_interpolated <- spec_array
  saturated_groups <- split(saturated_idx, cumsum(c(1, diff(saturated_idx) != 1)))
  
  for (group in saturated_groups) {
    start_idx <- max(1, min(group) - 1)
    end_idx <- min(length(spec_array), max(group) + 1)
    
    if (start_idx < min(group) && end_idx > max(group)) {
      x_vals <- c(start_idx, end_idx)
      y_vals <- c(spec_array[start_idx], spec_array[end_idx])
      for (idx in group) {
        spec_interpolated[idx] <- approx(x_vals, y_vals, idx)$y
      }
    }
  }
  return(spec_interpolated)
}
```

```{r}
visualize_saturation_patterns <- function(saturation_results,
                                          sensor_focus = "sensor_1",
                                          threshold = 60000) {
  p1 <- saturation_results$saturation_summary %>%
    ggplot(aes(x = sensor, y = saturation_rate, fill = saturation_rate)) +
    geom_col() +
    scale_fill_viridis_c(name = "Saturation\nRate (%)") +
    labs(
      title = "Saturation Rate by Sensor",
      x = "Sensor",
      y = "Saturation Rate (%)",
      caption = paste("Threshold:", threshold, "counts")
    ) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
  
  print(p1)
  
  p2 <- saturation_results$data %>%
    ggplot(aes(x = max_intensity, fill = is_saturated)) +
    geom_histogram(bins = 50, alpha = 0.7) +
    geom_vline(
      xintercept = threshold,
      color = "red",
      linetype = "dashed",
      size = 1
    ) +
    scale_fill_manual(values = c("FALSE" = "steelblue", "TRUE" = "red"),
                      name = "Saturated") +
    labs(
      title = "Distribution of Maximum Intensities",
      x = "Maximum Intensity",
      y = "Count",
      caption = "Red line shows saturation threshold"
    ) +
    theme_minimal()
  
  print(p2)
  
  sensor_data <- saturation_results$data %>%
    filter(sensor == sensor_focus) %>%
    mutate(datetime = as.POSIXct(datetime))
  
  if (nrow(sensor_data) > 0) {
    p3 <- sensor_data %>%
      ggplot(aes(x = datetime, y = max_intensity, color = is_saturated)) +
      geom_point(alpha = 0.7) +
      geom_hline(yintercept = threshold,
                 color = "red",
                 linetype = "dashed") +
      scale_color_manual(values = c("FALSE" = "steelblue", "TRUE" = "red"),
                         name = "Saturated") +
      labs(
        title = paste("Saturation Over Time -", sensor_focus),
        x = "Date/Time",
        y = "Maximum Intensity",
        caption = "Red line shows saturation threshold"
      ) +
      theme_minimal()
    
    print(p3)
  }
  
  return(
    list(
      saturation_by_sensor = p1,
      intensity_distribution = p2,
      time_series = if (exists("p3"))
        p3
      else
        NULL
    )
  )
}
```

```{r}
compare_saturation_handling <- function(nir_data,
                                        method = "interpolate",
                                        saturation_threshold = 60000,
                                        tube_example = NULL,
                                        sensor_example = "sensor_1") {
  results <- detect_and_handle_saturation(nir_data, saturation_threshold, method = method)
  if (is.null(tube_example)) {
    saturated_tubes <- results$data %>%
      filter(sensor == sensor_example, is_saturated == TRUE) %>%
      slice_head(n = 1)
    
    if (nrow(saturated_tubes) > 0) {
      tube_example <- saturated_tubes$tube_number[1]
    } else {
      tube_example <- results$data %>%
        filter(sensor == sensor_example) %>%
        slice_head(n = 1) %>%
        pull(tube_number)
    }
  }
  original_tube <- nir_data$corrected_spectra %>%
    filter(sensor == sensor_example, tube_number == tube_example) %>%
    slice_head(n = 1)
  
  processed_tube <- results$data %>%
    filter(sensor == sensor_example, tube_number == tube_example) %>%
    slice_head(n = 1)
  
  if (nrow(original_tube) > 0 && nrow(processed_tube) > 0) {
    comparison_data <- data.frame(
      wavelength_index = rep(1:length(original_tube$spec_array[[1]]), 2),
      intensity = c(original_tube$spec_array[[1]], processed_tube$spec_array[[1]]),
      type = rep(c("Original", paste("After", method)), each = length(original_tube$spec_array[[1]]))
    )
    
    p_compare <- comparison_data %>%
      ggplot(aes(x = wavelength_index, y = intensity, color = type)) +
      geom_line(size = 0.8) +
      geom_hline(
        yintercept = saturation_threshold,
        linetype = "dashed",
        color = "red",
        alpha = 0.7
      ) +
      scale_color_manual(values = c("Original" = "red", paste("After", method), "blue")) +
      labs(
        title = paste("Saturation Handling Comparison -", method),
        subtitle = paste("Tube", tube_example, "from", sensor_example),
        x = "Wavelength Index",
        y = "Corrected Intensity",
        color = "Processing",
        caption = "Red dashed line shows saturation threshold"
      ) +
      theme_minimal()
    
    print(p_compare)
  }
  return(results)
}
```

#### Detect and flag saturated spectra

```{r}
saturation_results <- detect_and_handle_saturation(
  nir_data, 
  saturation_threshold = 60000, 
  saturation_percentage = 0.05, 
  method = "flag"
  )
```

#### Visualize saturation patterns

```{r}
cat("\nCreating saturation visualization plots...\n")
saturation_plots <- visualize_saturation_patterns(saturation_results, "sensor_1", threshold = 60000)
```

#### Interpolation method

```{r}
#interpolated_results <- compare_saturation_handling(nir_data, method = "interpolate")
```

#### Removal and Capping methods

```{r}
removal_results <- compare_saturation_handling(nir_data, method = "remove")
```

```{r}
capped_results <- compare_saturation_handling(nir_data, method = "cap")
```


